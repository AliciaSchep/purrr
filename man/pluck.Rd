% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pluck.R
\name{pluck}
\alias{pluck}
\alias{chuck}
\alias{pluck_assign}
\alias{pluck<-}
\title{Pluck or chuck a single element from a vector or environment}
\usage{
pluck(.x, ..., .default = NULL)

chuck(.x, ...)

pluck_assign(x, where, value)

pluck(.x, ...) <- value
}
\arguments{
\item{.x, x}{A vector or environment}

\item{...}{A list of accessors for indexing into the object. Can be
an integer position, a string name, or an accessor function
(except for the assignment variants which only support names and
positions). If the object being indexed is an S4 object,
accessing it by name will return the corresponding slot.

These dots support \link[rlang:list2]{tidy dots} features. In
particular, if your accessors are stored in a list, you can
splice that in with \code{!!!}.}

\item{.default}{Value to use if target is empty or absent.}

\item{where, .where}{A pluck location, as a numeric vector of
positions, a character vector of names, or a list combining both.}

\item{value}{A value to replace in \code{.x} at the location specified
by accessors in \code{...}.}
}
\description{
\code{pluck()} and \code{chuck()} implement a generalised form of \code{[[} that
allow you to index deeply and flexibly into data structures.
\code{pluck()} consistently returns \code{NULL} when an element does not
exist, \code{chuck()} always throws an error in that case.
}
\details{
\itemize{
\item You can pluck or chuck with standard accessors like integer
positions and string names, and also accepts arbitrary accessor
functions, i.e. functions that take an object and return some
internal piece.

This is often more readable than a mix of operators and accessors
because it reads linearly and is free of syntactic
cruft. Compare: \code{accessor(x[[1]])$foo} to \code{pluck(x, 1, accessor, "foo")}.
\item These accessors never partial-match. This is unlike \code{$} which
will select the \code{disp} object if you write \code{mtcars$di}.
}
}
\examples{
# pluck() supports integer positions, string names, and functions.
# Using functions, you can easily extend pluck(). Let's create a
# list of data structures:
obj1 <- list("a", list(1, elt = "foobar"))
obj2 <- list("b", list(2, elt = "foobaz"))
x <- list(obj1, obj2)

# And now an accessor for these complex data structures:
my_element <- function(x) x[[2]]$elt

# The accessor can then be passed to pluck:
pluck(x, 1, my_element)
pluck(x, 2, my_element)

# Even for this simple data structure, this is more readable than
# the alternative form because it requires you to read both from
# right-to-left and from left-to-right in different parts of the
# expression:
my_element(x[[1]])

# If you have a list of accessors, you can splice those in with `!!!`:
idx <- list(1, my_element)
pluck(x, !!!idx)


# You can also assign a value in a pluck location (only for
# positions and names):
pluck(x, 2, 2, "elt") <- "quuux"
x

# This is a shortcut for the prefix function pluck_assign():
y <- pluck_assign(x, list(2, 2, "elt"), value = "QUUUX")
y
}
\seealso{
\code{\link[=attr_getter]{attr_getter()}} for creating attribute getters suitable
for use with \code{pluck()} and \code{chuck()}. \code{\link[=pluck_modify]{pluck_modify()}} for
applying a function to a pluck location.
}
