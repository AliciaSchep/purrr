% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reduce.R
\name{accumulate}
\alias{accumulate}
\title{Accumulate intermediate results of a vector reduction}
\usage{
accumulate(.x, .f, ..., .init, .dir = c("left", "right"))
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{For \code{reduce()}, a 2-argument function. The function will be
passed the accumulated value as the first argument and the "next" value
as the second argument.

For \code{reduce2()}, a 3-argument function. The function will be passed the
accumulated value as the first argument, the next value of \code{.x} as the
second argument, and the next value of \code{.y} as the third argument.}

\item{...}{Additional arguments passed on to the mapped function.}

\item{.init}{If supplied, will be used as the first value to start
the accumulation, rather than using \code{x[[1]]}. This is useful if
you want to ensure that \code{reduce} returns a correct value when \code{.x}
is empty. If missing, and \code{x} is empty, will throw an error.}

\item{.dir}{The direction of reduction as a string, one of \code{"left"}
or \code{"right"}. See the section about direction below.}
}
\value{
A vector the same length of \code{.x} with the same names as \code{.x}.

If \code{.init} is supplied, the length is extended by 1. If \code{.x} has
names, the initial value is given the name \code{".init"}, otherwise
the returned vector is kept unnamed.

If \code{.dir} is \code{"left"} (the default), the first element is the
initial value (\code{.init} if supplied, or the first element of \code{.x})
and the last element is the final reduced value. In case of a
right accumulation, this order is reversed.
}
\description{
\code{accumulate()} \link[=reduce]{reduces} a vector with a binary function,
keeping all intermediate results, from the initial value to the
final reduced value, i.e. the result you'd have gotten if you used
\code{\link[=reduce]{reduce()}} instead of \code{accumulate()}.
}
\section{Life cycle}{


\code{accumulate_right()} is soft-deprecated in favour of the \code{.dir}
argument as of rlang 0.3.0. Note that the algorithm has
slightly changed: the accumulated value is passed to the right
rather than the left, which is consistent with a right reduction.
}

\examples{
# With an associative operation, the final value is always the
# same, no matter the direction. You'll find it in the last element
# for a left accumulation, and in the first element for a right one:
1:5 \%>\% accumulate(`+`)
1:5 \%>\% accumulate(`+`, .dir = "right")

# The final value is always equal to the equivalent reduction:
1:5 \%>\% reduce(`+`)

# It is easier to understand the details of the reduction with
# `paste()`.
accumulate(letters[1:5], paste, sep = ".")

# Note how the intermediary reduced values are passed to the left
# with a left reduction, and to the right otherwise:
accumulate(letters[1:5], paste, sep = ".", .dir = "right")


# Simulating stochastic processes with drift
\dontrun{
library(dplyr)
library(ggplot2)

rerun(5, rnorm(100)) \%>\%
  set_names(paste0("sim", 1:5)) \%>\%
  map(~ accumulate(., ~ .05 + .x + .y)) \%>\%
  map_dfr(~ data_frame(value = .x, step = 1:100), .id = "simulation") \%>\%
  ggplot(aes(x = step, y = value)) +
    geom_line(aes(color = simulation)) +
    ggtitle("Simulations of a random walk with drift")
}
}
\seealso{
\code{\link[=reduce]{reduce()}} when you only need the final reduced value.
}
